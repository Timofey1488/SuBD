## Триггеры
Здесь представлена теория и некоторые тригеры которые использовались при написании лабороторной работы для СУБД

## Теория
Триггер определяет операцию, которая должна выполняться при наступлении некоторого события в базе данных.  Триггеры срабатывают при выполнении с таблицей команды SQL INSERT, UPDATE или DELETE.
В  PostgreSQL триггеры создаются на основе существующих функции, т.е. сначала  командой  CREATE FUNCTION определяется  триггерная функция, затем на ее основе  командой CREATE TRIGGER  определяется собственно триггер.

Синтаксис определения триггера:

```SQL
CREATE TRIGGER триггер
BEFORE | AFTER } { событие [ OR событие ] } ON таблица
FOR EACH { ROW |  STATEMENT }
EXECUTE PROCEDURE функция ( аргументы )
```

*  `CREATE TRIGGER` триггер. В аргументе триггер указывается произвольное имя создаваемого триггера. Имя может совпадать с именем триггера, уже существующего в базе данных   при условии, что этот триггер установлен для другой таблицы. Кроме того, по аналогии с большинством других несистемных объектов баз данных, имя триггера (в сочетании с таблицей, для которой он устанавливается) должно быть уникальным лишь в контексте базы данных, в которой он создается
* `{ BEFORE | AFTER }`. Ключевое слово BEFORE означает, что функция должна выполняться  перед попыткой выполнения операции, включая все встроенные проверки ограничений данных, реализуемые при выполнении команд INSERT и DELETE. Ключевое слово AFTER означает, что функция вызывается после завершения операции, приводящей в действие триггер.
* `{ событие [ OR событие ... ] }`. События SQL, поддерживаемые в PostgreSQL: INSERT, UPDATE или DELETE. При перечислении нескольких событий в качестве разделителя используется ключевое слово OR.
* `ON таблица**. Имя таблицы, модификация которой заданным событием приводит к срабатыванию триггера.
* `FOR EACH { ROW | STATEMENT }`. Ключевое слово, следующее за конструкцией FOR EACH и определяющее количество вызовов функции при наступлении указанного события. Ключевое слово ROW означает, что функция вызывается для каждой  модифицируемой записи. Если функция должна вызываться всего один раз для всей команды, используется ключевое слово STATEMENT.
*  `EXECUTE PROCEDURE функция ( аргументы )`. Имя вызываемой функции с аргументами. На  практике аргументы  при вызове триггерных функций не используются.

Синтаксис определения триггерной  функции:

```SQL
CREATE FUNCTION функция () RETURNS trigger AS '
DECLARE
        объявления ;
BEGIN
команды;
END; '
LANGUAGE  plpgsql;
```

| Имя переменной       | Тип                | Описание |
| :-------------: |:------------------:| :-----|
| NEW | RECORD | Переменная содержит новую строку базы данных для команд INSERT/UPDATE в триггерах уровня строки. В триггерах уровня оператора и для команды DELETE этой переменной значение не присваивается. |
| OLD | RECORD | Переменная содержит старую строку базы данных для команд UPDATE/DELETE в триггерах уровня строки. В триггерах уровня оператора и для команды INSERT этой переменной значение не присваивается. |
| TG_NAME | name | Переменная содержит имя сработавшего триггера. |
| TG_WHEN | text | Строка, содержащая BEFORE, AFTER или INSTEAD OF, в зависимости от определения триггера. |
| TG_LEVEL | text | Строка, содержащая ROW или STATEMENT, в зависимости от определения триггера. |
| TG_OP | text | Строка, содержащая INSERT, UPDATE, DELETE или TRUNCATE, в зависимости от того, для какой операции сработал триггер. |
| TG_RELID | oid | OID таблицы, для которой сработал триггер. |
| TG_TABLE_NAME | name | Имя таблицы, для которой сработал триггер.|
| TG_TABLE_SCHEMA | name | Имя схемы, содержащей таблицу, для которой сработал триггер.|
| TG_NARGS | integer | Число аргументов в команде CREATE TRIGGER, которые передаются в триггерную процедуру. |
| TG_ARGV[] | text | Аргументы от оператора CREATE TRIGGER. Индекс массива начинается с 0. Для недопустимых значений индекса ( < 0 или >= tg_nargs) возвращается NULL. |

Триггерная функция должна вернуть либо NULL, либо запись/строку, соответствующую структуре таблице, для которой сработал триггер.

Если BEFORE триггер уровня строки возвращает NULL, то все дальнейшие действия с этой строкой прекращаются (т. е. не срабатывают последующие триггеры, команда INSERT/UPDATE/DELETE для этой строки не выполняется). Если возвращается не NULL, то дальнейшая обработка продолжается именно с этой строкой. Возвращение строки отличной от начальной NEW, изменяет строку, которая будет вставлена или изменена. Поэтому, если в триггерной функции нужно выполнить некоторые действия и не менять саму строку, то нужно возвратить переменную NEW (или её эквивалент). Для того чтобы изменить сохраняемую строку, можно поменять отдельные значения в переменной NEW и затем её вернуть. Либо создать и вернуть полностью новую переменную. В случае строчного триггера BEFORE для команды DELETE само возвращаемое значение не имеет прямого эффекта, но оно должно быть отличным от NULL, чтобы не прерывать обработку строки. Обратите внимание, что переменная NEW всегда NULL в триггерах на DELETE, поэтому возвращать её не имеет смысла. Традиционной идиомой для триггеров DELETE является возврат переменной OLD.

Триггеры INSTEAD OF (это всегда триггеры уровня строк и они могут применяться только с представлениями) могут возвращать NULL, чтобы показать, что они не выполняли никаких изменений, так что обработку этой строки можно не продолжать (то есть, не вызывать последующие триггеры и не считать строку в числе обработанных строк для окружающих команд INSERT/UPDATE/DELETE). В противном случае должно быть возвращено значение, отличное от NULL, показывающее, что триггер выполнил запрошенную операцию. Для операций INSERT и UPDATE возвращаемым значением должно быть NEW, которое триггерная функция может модифицировать для поддержки предложений INSERT RETURNING и UPDATE RETURNING (это также повлияет на значение строки, передаваемое последующим триггерам, или доступное под специальным псевдонимом EXCLUDED в операторе INSERT с предложением ON CONFLICT DO UPDATE). Для операций DELETE возвращаемым значением должно быть OLD.

Возвращаемое значение для строчного триггера AFTER и триггеров уровня оператора (BEFORE или AFTER) всегда игнорируется. Это может быть и NULL. Однако в этих триггерах по-прежнему можно прервать вызвавшую их команду, для этого нужно явно вызвать ошибку.
## Тригеры, использованые в работе:
### 1)Триггер, отвечающий за логирование клиента при INSERT, UPDATE

Тригер вызывает тригерную функцию, которая срабатывает при вставке или обновлении таблицы клиента.
Пример данной функции:

```SQL
CREATE OR REPLACE FUNCTION add_to_log() RETURNS TRIGGER AS $$
DECLARE
    mstr varchar(30);
    astr varchar(100);
    retstr varchar(254);
BEGIN
    IF    TG_OP = 'INSERT' THEN
        astr = NEW.name;
        mstr := 'Add new client ';
        retstr := mstr || astr;
        INSERT INTO logger(log_text,log_date) values (retstr,NOW());
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        astr = NEW.name;
        mstr := 'Update client ';
        retstr := mstr || astr;
        INSERT INTO logger(log_text,log_date) values (retstr,NOW());
        RETURN NEW;

END;
$$ LANGUAGE plpgsql;
```
Сам же триггер описывается ниже:

```SQL
CREATE TRIGGER trigger_clients
AFTER INSERT OR UPDATE ON clients 
FOR EACH ROW EXECUTE PROCEDURE add_to_log ();
```

### 2)Триггер, создающий таблицу payments для клиента непостредственно после создания клиента

```SQL
CREATE OR REPLACE FUNCTION new_payments_client() RETURNS TRIGGER AS $create_payments_client$
	BEGIN
		INSERT INTO payments(pk_payments_id,fk_clients_id) 
		VALUES ((SELECT MAX(pk_payments_id) FROM payments)+1, (SELECT MAX(pk_clients_id) FROM clients)+1);
	RETURN NULL;
END;
$create_payments_client$ LANGUAGE plpgsql;

CREATE TRIGGER create_payments_client 
AFTER INSERT ON clients
FOR EACH ROW
EXECUTE PROCEDURE new_payments_client();
```

### 3)Триггер, удаляющий товары из корзины, когда заказ сформирован
```SQL
CREATE OR REPLACE FUNCTION delete_products() RETURNS TRIGGER AS $delete_product_from_product_cart$
	BEGIN
		DELETE FROM product_cart
		WHERE product_cart.cart_id = (SELECT MAX(cart_id) FROM cart);
	RETURN NULL;
END;
$delete_product_from_product_cart$ LANGUAGE plpgsql;

CREATE TRIGGER delete_product_from_product_cart
AFTER INSERT ON orders
FOR EACH ROW
EXECUTE PROCEDURE delete_products();
```
